저자의 의도
	"개발자가 항상 유니코드 문자와 새로운 안전 문자열 함수를 이용하여 개발할 것을 강조하기 위함이다. 
	이를 통하여 애플리케이션의 수행성능을 향상시킬 수 있고 애플리케이션의 지역화를 좀 더 쉽게 할 수 있다. 
	뿐만 아니라 COM이나 닷넷 프레임워크와의 상호운용에도 상당한 도움이 된다."

1 문자 인코딩
	몇몇 언어와 글쓰기 방법이 상당히 많은 문자들로 구성되어 있어 1바이트로는 충분하지 않다 이런 언어와 글쓰기 방법을 지원하기 위해 DBCS(double-bytes character set)가 만들어 졌는데,
	각각의 문자는 1바이트 혹은 2바이트가 될 수 있다.

	UTF-8
		UTF-8은 문자가 0x0080 미만에 있다면 이러한 문자는 1byte로 인코딩된다.
		문자가 0x0080과 0x07FF 범위 내에 있다면 이것은 2바이트로 인코딩된다.
		0x0800 이상의 문자들은 3바이트로 인코딩되며, 4바이트로 문자를 표현할 수 있는 방법을 제공한다.
		UTF-8은 매우 일반적인 인코딩 방식이지만 0x0800 이상의 문자를 많이 사용할 경우 비효울적이다.

	UTF-32
		UTF-32는 모든 문자를 4바이트로 인코딩한다. 이러한 인코딩 방식은 문자 변환 알고리즘을 간단히 구성하려 할 때나 가변 길이의 인코딩 방식을 사용하고 싶지 않은 경우에 유용하다.
		UTF-32는 메모리 사용에 있어 매우 비효율족인 인코딩 방식이기 때문에 파일 저장 방식이나 네트워크를 통한 전송 방식으로는 거의 사용되지 않는다.

2 ANSI 문자와 유ㅠ니코드 문자 그리고 문자열 자료형
	C/C++ 컴파일러는 16비트 유니코드를 표현하기 위한 wchar_t자료형을 내장자료형으로 처리할 수 있는 기능이 추가되었다.

	유니코드 문자와 유니코드 문자열은 다음과 같이 선언한다.
		//16비트 문자
		wchar_t c = L'A';

		// 99개의 16비트 문자와 16비트 문자열 종결 문자(0)
		wchar_t szBuffer[100] = L"A String";
	문자열 앞의 대문자 L은 컴파일러가 문자열을 유니코드로 다루도록 한다.

	C언어의 자료형으로 부터 윈도우 자신의 자료형을 구분 짓기 위해 WinNT.h 헤더 파일에 다음과 같이 자료형을 정의하고 있다.
		typedef char CHAR; // 8비트 문자
		typedef wchar_t WCHAR; // 16비트 문자
		
	뿐만 아니라 WinNT.h 헤더 파일으 편의를 위해 문자와 문자열을 가리키는 포인터 자료형에 대해 다음과 같이 정의한다.
		// 8비트 문자(열)를 가리키는 포인터
		typedef CHAR *PCHAR;
		typedef CHAR *PSTR;
		typedef CONST CHAR *PCSTR;

		// 16비트 문자(열)을 가리키는 포인터
		typedef WCHAR *PWCHAR;
		typedef WCHAR *PWSTR;
		typedef CONST WCHAR *PCWSTR;

	컴파일 시 ANSI 문자(열)나 유니코드 문자(열)를 사용하도록 변경 가능하게 소스 코드를 작성하는 것도 가능하다.
	WinNT.h 헤더 파일의 매크로

		#ifdef UNICODE
		
		typedef WCHAR TCHAR, *PTCHAR, PTSTR;
		typedef CONST WCHAR *PCTSTR;
		#define __TEXT(quote) L##quoto

		#else

		typedef CHAR TCHAR, *PTCHAR, PTSTR;
		typedef CONST CHAR *PCTSTR;
		#define __TEXT(quoto) quoto

		#endif
		
		#define TEXT(quoto) __TEXT(quoto)
	이런 자료형과 매크로를 이용하면 컴파일 시 ANSI 문자(열)나 유니코드 문자(열)를 사용하도록 변경 가능한 단일의 소스 코드를 작성할 수 있다.

3 윈도우 내의 유니코드 함수와 ANSI 함수
	HWND WINAPI CreateWindowExW(
    _In_ DWORD dwExStyle,
    _In_opt_ LPCWSTR lpClassName, // 유니코드 문자열
    _In_opt_ LPCWSTR lpWindowName, // 유니코드 문자열
    _In_ DWORD dwStyle,
    _In_ int X,
    _In_ int Y,
    _In_ int nWidth,
    _In_ int nHeight,
    _In_opt_ HWND hWndParent,
    _In_opt_ HMENU hMenu,
    _In_opt_ HINSTANCE hInstance,
    _In_opt_ LPVOID lpParam);

	HWND WINAPI CreateWindowExA(
    _In_ DWORD dwExStyle,
    _In_opt_ LPCSTR lpClassName, // ANSI 문자열
    _In_opt_ LPCSTR lpWindowName, // ANSI 문자열
    _In_ DWORD dwStyle,
    _In_ int X,
    _In_ int Y,
    _In_ int nWidth,
    _In_ int nHeight,
    _In_opt_ HWND hWndParent,
    _In_opt_ HMENU hMenu,
    _In_opt_ HINSTANCE hInstance,
    _In_opt_ LPVOID lpParam);
	
	함수명 끝에 추가된 W는 wide를 의미하고 A는 ANSI 문자열을 인자로 취한다는 의미이다.

	WinUser.h 파일을 보면 CreateWindowEx는 실제로 이렇게 매크로로 정의되어 있다.
	#ifdef UNICODE
	#define CreateWindowEx  CreateWindowExW
	#else
	#define CreateWindowEx  CreateWindowExA
	#endif // !UNICODE

	UNICODE 정의 여부에 따라 어떤 버전의 CreateWindowEX 함수가 호출될지가 결정된다. visual studio에서 새로운 프로젝트를 생성하게 되면 기본적으로 UNICODE가 정의되어 있다.
	따라서, CreateWindowEX 매크로를 이용한 함수 호출은 유니코드 버전의 CreateWindowEx인 CreateWindowExW로 변경된다.

	윈도우 비스타에서 CreateWindowExA 함수는 내부적으로 단순히 버퍼로 사용할 메모리를 확보하고
	ANSI 문자열을 유니코드 문자열로 변경하는 단계를 추가적으로 수행한 후 변경된 문자열로 CreateWindowExW 함수를 호출한다.
	호출한 CreateWindowExW함수가 반환되면 CreateWindowExA는 버퍼로 할당했던 메모리를 삭제하고 윈도우 핸들을 반환한다.
	버퍼를 문자열로 채우는 함수들의 경우에는 시스템이 항상 유니코드 문자열을 유니코드가 아닌 문자열로 변경을 수행해야 한다.
	"이 과정에서 애플리케이션은 더 많은 메모리를 소비하고 더 느리게 동작하게 된다."
	"애플리케이션을 좀더 효율적으로 동작하게 하기 위해서는 처음부터 유니코드를 사용하도록 애플리케이션을 개발하는 것이 좋다."

	WinExec와 OpenFile과 같은 몇몇 윈도우 API들은 16비트 윈도우용으로 제작된 프로그램과의 호환성을 위해서만 유지되고 있기 때문에 인자로 ANSI 문자열만을 지원한다.
	그래서 CreateProcess와 CreateFile을 사용하는 것이 좋다.
	오래된 함수의 가장 큰 묹는 이러한 함수들이 유니코드 문자열을 받아들이지 못할 뿐더러 제공하는 기능도 더 적다는 것이다.
	
	마이크로 소프트는 16비트 윈도우의 COM을 Win32로 포팅할 당시 COM 인터페이스를 통해 문자열을 전달하는 경우 유니코드 문자열만을 사용하도록 하였다.
	 COM은 일반적으로 서로 다른 컴포넌트 사이의 호출 규격을 정의하고 있으므로 문자열을 전달할 때 유니코드만을 사용하게다고 결정한 것은 올바른 선택이다!
	이러한 이유로 애플리케이션 개발 시 유니코드를 사용하면 COM컴포넌트와도 좀 더 쉽게 상호 운용될 수 있다.

	마지막으로, 리소스 컴파일러가 리소스를 컴파일하면 이진 파일이 생성된다. 이러한 파일 내의 문자열은 항상 유니코드 문자열로 구성된다.
	소스 모듈을 컴파일할 때 UNICODE가 정의되어 있지 않으면 loadStrig 함수는 실제로 LoadStringA 함수를 호출하게 되는데, 
	LoadStringA는 리소스로부터 유니코드 문자열을 읽고 이를 ANSI 문자열로 변경한 후 반환한다.

4 C 런타임 라이브러리 내의 유니코드 한수와 ANSI 함수
	윈도우 함수와 마찬가지로 C 런타임 라이브러리도 ANSI문자(열)를 다루는 함수와 유니코드 문자(열)을 다루는 함수를 세트로 제공하고 있다.
	윈도우 함수와는 다르게 C런타임 라이브러리가 제공하는 ANSI함수는 여전히 잘 동작하며, 유니코드로의 변경을 수행하지 않을 뿐더러 내부적으로 유니코드 버전의 함수를 호출하지도 않는다.
	물론 유니코드 버전의 함수도 잘 동작하며, 내부적으로 ANSI 버전의 함수를 호출하지도 않는다.

	C런타임 라이브러리의 대표적인 함수로 ANSI문자열의 길이를 반환하는 strlen 함수와 유니코드 문자열에 대해 동일한 기능을 수행하는  wcslen 함수가 있는데 이 함수들의 원형은 String.h에 정의되어 있으니,
	ANSI와 유니코드 환경에서 모두 컴파일될 수 있는 코드를 작성하려면 다음과 같은 매크로가 정의되어있는 TChar.h 헤더 파일을 참조해야 한다.
	(tchar.h의 _unicode에 관한 내용이 너무 많이 기술되어있어 잘라옴)
		#ifdef _UNICODE
		#define _tcslen     wcslen
		#else
		#define _tcslen     strlen
		#endif

	코드에서 가능한 한 _tcslen을 사용하는 것이 좋다. _tcslen을 사용하면 _UNICODE가 정의되어 있는 경우 wcslen으로 변경되고, 그렇지 않으면 strlen으로 변경된다.
	기본적으로 visual studio에서 C++프로젝트를 생서알면 _UNICODE가 정의된다.

5 C런타임 라이브러리 내의 안전 문자열 함수
	문자열을 다루는 함수는 항시 잠재적인 위험에 노출되어 있다. 만일 결과를 담기 위한 문자열 버퍼가 결과를 담기에 충분하지 않다면 메모리 관련 문제가 발생할 것이다.

	strcpy와 wcscpy 함수의 문제점은 버퍼의 최대 크기를 인자로 받지 않는다는 것이다. 그래서 메모리에 문제가 생겨도 에러를 보고받을 수 없었고 메로리가 정상적으로 운용되고 있는지를 알 방법도 없었다.
	차라리 함수가 실패하는게 낫다.

	그래서 저자는 안전한 코드를 작성하고 싶다면 지금껏 익숙하게 사용해왔던 C런타임 라이브러리 내의 문자열 조작 함수는 더 이상 사용하지 말길 바란다고 말한다.
	예외로 strlen, wcslen, _tcslen 등은 여전히 사용해도 무방한데 그 이유는 이러한 함수들은 전달된 문자열을 수정하려 시도하지 않으며, 종결 문자(\0)만 저달해도 문제가 되지 않기 때문.
	대신 마이크로소프트가 strsafe.h 파일을 통해 새로이 제공하는 안전 문자열 함수를 사용하는게 좋다.
	
	새로운 안전 문자열 함수에 대한 소개
		strsafe.h 헤더 파일을 포함하면 string.h 헤더 파일도 같이 포함된다. strsafe.h.에 대한 include 구문은 다른 include 구문보다 반드시!! 뒤쪽에 위치되어야 한다.
		컴파일 시 관련 경고를 유발한 구문들은 잠재적으로 버퍼 오버플로를 발생시킬 가능성이 있으며, 이는 복구가 불가능하다.

		예시로 _tcscpy_s, _tcscat_s (_s는 secure를 의미함)의 정의와 구조를 보자.
		
		PTSTR _tcscpy (PTSTR strDestination, PCTSTR strSource);
		errno_t _tcscpy_s(PTSTR strDestination, size_t numberOfCharacters, PCTSTR strSource);

		PTSTR _tcsCat (PTSTR strDestination, PCTSTR strSource);
		errno_t _tcscat_s(PTSTR strDestination, size_t numberOfcharacters, PCTSTR strSource);

		이러한 함수들은 쓰여질 버퍼와 함께 버퍼의 크기도 인자로 전달하도록 정의되어 있다. 이 값으로 는 문자의 개수를 전달해야 한다.
		안전문자열 함수는 내부적으로 가장 먼저 인자의 유효성을 검증한다. 
		이러한 검증단계에서는 인자 값이 NULL인지, 정수 값이 유효한 범위 내에 있는지, 열거형 값이 유효한지, 버퍼는 결과를 저장할 만큼 충분한지 등을 테스트한다.

		C런타임 라이브러리는 인자의 유효성 검증이 실패하였을 경우 사용자가 정의한 함수를 통해 에러 내용을 전달할 수 있는 기능을 제공하고 있다.
		이러한 함수를 이용하면 에러를 기록하거나 디버거를 기동하는 등의 사용자 작업을 수행할 수 있다.

		이를 위해 원형의 함수를 작성해야 한다.
		
		void invalidParameterHandler(PCTSTR expression, PCTSTR function, PCTSTR file, unsigned int line, uintptr_t /*pReserved*/);

		expression 매개변수는 (L"Buffer is too small" && 0)와 같이 C 런타임 한수 내에서 발생한 테스트 실패에 대해 설명하는 문자열이 전달되며,
		뒤따라오는 function, file, line 매개변수를 통해 각각 함수 이름, 소스 파일명, 에러가 발생한 소스 코드의 행 번호와 같은 정보가 전달된다.

		다음단계로 _set_invalid_parameter_handler를 호출하여 앞서 작성한 함수를 등록해야 한다.
		하지만 여전히 이설션 다이얼로그 박스는 나타날 것이기 떄문에 _CrtSetReportMoode(_CRT_ASSERT, 0)을 애플리케이션 시작 시점에 호출하여 C 런타임이 어설션 다이얼로그 박스를 띄우지 않도록 해야하며
		String.h에 정의된 기존 문자열 함수를 대체하는 안전 ㅁ누자열 함수들을 사용하면 된다.
		정상 수행되었는지 여부를 확인하려면 반환되는 errno_t 값을 확인하면 된다 S_OK가 반환되면 한수가 성공한 것이다.

	문자열 조작을 수행하는 동안 좀더 많은 제어를 수행할 수 있도록 하는 방법
		문자열 잘림을 어떻게 처리할지를 세부적으로 지정하는 방법.

		StringCchCat, StringCchCatEx
		StringCchCopy, StringCchCopyEx
		StringCchPrintf, StringCchPrintfEx
		등이 있으며 모든 함수가 함수명에 "Cch"를 포함하고 있는데 이는 count of Characters(문자의 개수)를 의미하며 보통의 경우 _countof 매크로를 이용하면 적절한 값을 전달할 수 있다.
		StringCbCat(Ex), StringCbCopy(Ex), StringCbPrintf(Ex)와 같이 "Cb"를 포함하고 있는 함수들은 인자로 Count of bytes(바이트 수)를 요구하며 보통의 경우 sizeof연산자를 이용하면 적절한 값을 전달할 수 있다.

		_s로 끝나는 안전 문자열 함수와는 달리 이러한 함수들은 버퍼가 충분하지 않을 경우 문자열 잘림이 수행되며, 이 경우 STRSAFE_E_INSUFFICIENT_BUFFER 값이 반환된다.

	윈도우의 문자열 함수
		문자열 간의 비교나 정렬등은 매우 일반적인 작업들인데, 이를 위한 최상의 함수는 CompareString(Ex)와 CompareStringOrdinal이다.
		CompareString(Ex)를 사용하면 언어적으로 올바른 비교를 수행할 수 있다.		

		int CompareString(
			LCID     Locale,
			DWORD    dwCmpFlags,
			LPCTSTR  lpString1,
			int      cchCount1,
			LPCTSTR  lpString2,
			int      cchCount2);

		첫 번째 매개변수로는 각 언어별로 고유한 32비트 값인 지역ID를 전달하면 된다.
		두 번째 매개변수로에는 두 문자열의 비겨 방법을 조정하는 플래그 값을 전달한다.
		나머지 4개의 매개변수에는 두 개의 문자열과 각 문자열을 구성하는 문자의 개수가 전달된다. 만일 cch1로 음수 값을 주면 pString1이 0으로 끝나는 문자열이라고 가정한다.

		프로그램 내에서 사용하는 일반적인 문자열을 비교하기 위해서는 CompareStringOrdinal을 사용한다.
			
			int WINAPI CompareStringOrdinal(
				_In_NLS_string_(cchCount1) LPCWCH lpString1,
				_In_ int cchCount1,
				_In_NLS_string_(cchCount2) LPCWCH lpString2,
				_In_ int cchCount2,
				_In_ BOOL bIgnoreCase);
		
		이 함수는 지역 설정을 고려하지 않고 단순히 값에 의한 비교만을 수행하기 때문에 상대적으로 빠르게 수행된다. 
		프로그램 내에서만 사용하는 문자열은 최종 사용자에게 보여지지 않는 경우가 대부분이므로 이 함수를 사용하는 것이 가장 좋다.
		이 함수는 유니코드 문자열만을 인자로 취한다는 점에 주의하자.

		CompareString과 CompareStringOrdinal 함수의 반환 값은 C런타임 라이브러리의 *cmp 형태의 문자열 비교 함수의 반환 겂과 거의 반대의 의미를 가진다.
		즉 0은 호출 실패
		1은 pstring1 < pstring2
		2는 pstring1 = pstring2
		3은 pstring1 > pstring2

왜 유니코드를 사용하는 것이 좋은가?
	
	1. 유니코드를 사용하면 다른 나라의 언어로 애플리케이션을 지역화하기가 쉽다.
	2. 유니코드는 사용하면 단일의 바이너리 파일로 모든 언어를 지원할 수 있다.
	3. 유니코드를 사용하면 코드가 더 빠르게 수행되며 더 작은 메모리를 사용하기 때문에 애플리케이션의 효율성이 증대한다.
	   윈도우는 내부적으로 유니코드로 구성된 문자와 문자열을 사용하기 때문에 ANSI 문자나 문자열을 전달할 경우 내부적으로 새로운 메모리를 할당하고 ANSI 문자와 문자열을 유니코드로 변경해야 한다.
	4. 유니코드를 사용하면 윈도우가 제공하는 모든 함수를 쉽게 사용할 수 있다. 몇몇 윈도우 함수는 유니코드 문자나 문자열만을 받아들일 수 있도록 작성되었다.
	5. 유니코드를 사용하면 COM과의 상호 운용이 쉽다(COM은 유니코드 문자와 문자열을 사용한다.)
	6. 유니코드를 사용하면 닷넷 프레임워크와 상호 운용이 쉽다.(닷넷 프레임워크 또한 유니코드 문자와 문자열만 사용한다.)
	7. 유니코드를 사용하면 리소스를 쉽게 다룰 수 있다.(리소스 내의 문자열은 모두 유니코드로 유지된다.)

문자와 문자열 작업에 대한 권고사항
	개발시 항상 염두에 두어야 하는 사항들
		1. 문자열을 char 타입이나 byte의 배열로 생각하지 말고, 문자의 배열로 생각하라.
		2. 문자나 문자열을 나타낼 때 중립 자료형(TCAHR/PTSTR과 같은)을 사용하라
		3. 바이트나 바이트를 가리키는 포인터, 데이터 버퍼 등을 표현하기 위헤서는 명시적인 자료형(BYTE나 PBYTE와 같은)을 사용하라.
		4. 문자나 문자열 상수 값을 표현할 때에는 TEXT나 _T 매크로를 사용하라. 일관성과 가동석을 유지하기 위해 두 개의 매크로를 혼용해서는 안된다.
		5. 문자나 문자열과 관련된 자료형을 야플리케이션 전반에 걸쳐 변경하라(ex. PSTR을 PTSTR로 변경하라)
		6. 문자열에 대한 산술적인 계산 부분을 수정하라. 예를 들어 보통의 함수들은 버퍼의 크기를 전달해야 할 때 바이트 단위가 아닌 문자 단위로 값을 전달한다.
		   그렇기 때문에 sizeof를 사용하는 대신 _countof를 사용해야 한다.
		    또한 문자열을 저장하기 위한 메모리 블럭을 할당해야 하고, 문자열을 구성하는 문자의 개수를 알고 있는 경우 메모리 할당은 바이트 단위로 수행해야 함을 잊어서는 안 된다.
		   즉, malloc(nCharacters)을 써서는 안되고, malloc(nCharacters * sizeof(TCHAR))을 써야한다.
		   앞서 나열한 방법과는 다르게 이 방법은 상당히 기억하기 까다롭고 실수를 하더라도 컴파일러가 어떠한 경고나 에러도 발생시키지 않는다.
		   따라서 아래와 같은 매크로를 정의해 두는 것도 상당히 유용한 방법이다.
				#define chmalloc(nCharacters) (TCHAR*)malloc(nCharacters * sizeof(TCHAR));

		7. printf 류의 함수를 사용하는 것은 피하라. 특히 ANSI 문자열을 유니코드 문자열로 변경하거나 그 반대로 변경을 수행하기 위해 %d, %s 등을 사용하는 것은 좋지 않다.
		   대신, MultiByteToWideChar와 WideCharToMultiByte 함수를 사용하라.
		8. UNICODE와 _UNICODE 심벌은 항상 동시에 정의하거나 해제하라.

	문자열을 다루는 함수를 사용할 경우의 가이드라인
		1. 항상 함수의 이름이 _s로 끝나거나 StringCch로 시작하는 안전 문자열을 사용하라. 함수 사용 이후에는 문자열 잘림에 대비하라
		2. C런타임 라이브러리가 제공하고 있는 함수 중 아전하지 않은 문자열 함수는 사용하지마라.
		3. 컴파일러가 자동적으로 버퍼 오퍼런을 감지할 수 있도록 /GS와 /RTCs 컴파일러 플래그를 활용하라.
		4. kernel32가 제공하는 lstrcat, lstrcpy 등의 문자욜 관련 함수를 사용하지 마라.
		5. 코드 내에서 문자열을 비교하는 데이는 두 가지 방법이 있다. 프로그램 내에서만 주로 사용하는 파일명, 경로명, XML 요소나 특성, 레지스트리 키/값 등을 비교하기 위해서는 CompareStringOrdinal을 사용하라.
		   사용자의 유저 인터페이스를 구성하는 문자열의 경우라면 CompareString(Ex)를 사용하는 것이 좋다.

유니코드 문자열과 ANSI 문자열 사이의 변경
	멀티바이트-문자 문자열을 와이드-문자 문자열로 변경하기 위해서는 MultiByteToWideChar 윈도우 함수를 사용한다.
	
	MultiByteToWideChar(
    _In_ UINT CodePage,
    _In_ DWORD dwFlags,
    _In_NLS_string_(cbMultiByte) LPCCH lpMultiByteStr,
    _In_ int cbMultiByte,
    _Out_writes_to_opt_(cchWideChar,return) LPWSTR lpWideCharStr,
    _In_ int cchWideChar);
	
	uCodePage 매개변수는 멀티바이트 문자열과 관련된 코드 페이지를 지정한다.
	dwflags 매개변수에는 악센트 기호와 같은 발음을 위한 특수 기호에 대한 추가적인 제어를 수행하기 위해 플래그 전달한다.(보통은 0)
	pMultiByteStr 매개변수에는 변결할 문자열을 전달하고, cbMultiByte 매개변수에는 변경할 문자열의 길이를(바이트 단위)로 전달한다.(-1로 지정하면 자동으로 계산)
	pWideCharStr 매개변수에는 유니코드로 변경된 문자열을 저장하기 위한 메모리 버퍼의 주소를 전달한다.
	CchWideChar 매개변수로는 버퍼의 최대 크기를(문자단위로) 전달한다.
	
	일반적인 단계.
		1. pWideCharStr 매개변수에 NULL, CchwideChar 매개변수에 0, cbMultiByte 매개변수에 -1를 주어 MultiByteToWideChar 함수 호출
		2. 유니코드 문자열로의 변경에 필요한 충분한 메모리 공간을 할당한다. 이크기는 아서 호출한 MultiByteToWideChar 함수의 반환 값에 sizeof를 곱한 값을 근간으로 계산할 수 있다.
		3. MultiByteToWideChar 함수를 재호출한다. 이번에는 pWideCharStr에 할당된 버퍼의 주소를 전달하고, CchWideChar에 앞서 호출한 MultiByteToWideChar 함수의 반환 값을 전달한다.
		4. 변경된 유니코드 문자열을 사용한다.
		5. 유니코드 문자열에 의해 점유된 메모리 공간을 해제한다.

	와이드-문자 문자열을 멀티바이트0문자 문자열로 변경하기 위해서 WideCharToMultiByte 함수를 사용하면 된다.
	
	WideCharToMultiByte(
    _In_ UINT CodePage,
    _In_ DWORD dwFlags,
    _In_NLS_string_(cchWideChar) LPCWCH lpWideCharStr,
    _In_ int cchWideChar,
    _Out_writes_bytes_to_opt_(cbMultiByte,return) LPSTR lpMultiByteStr,
    _In_ int cbMultiByte,
    _In_opt_ LPCCH lpDefaultChar,
    _Out_opt_ LPBOOL lpUsedDefaultChar);
	
	앞서 본 함수와 매우 유사하고 uCodePage 매개변수로는 새롭게 변경될 문자열과 관련된 코드 페이지를 전달한다.
	dwFlags 매개변수를 지정하면 문자열 변경 작업 이외의 추가적인 작업을 수행할 수 있는데, 발음을 위한 특수기호와 시스템이 변경하지 못하는 문자에 대한 특수 동작을 한다.(일반적으로 0)
	pWideCharStr 매개변수에는 변경할 문자열을 담고 있는 메모리 주소를 전달하고, CchWideChar 매개변수에는 문자열의 길이(문자단위)를 전달한다.
	CchWideChar 매개변수로 -1을 전달하면 변경할 문자열의 길이를 자동으로 결정해 준다.
	멀티바이트-문자 문자열이 저장될 pMultiByteStr 매개변수로는 문자열을 저장할 수 있는 충분한 크기의 버퍼를 전달해야 하고,
	cbMultiByte 매개변수로는 버퍼의 최대 크기(바이트 단위)를 전달해야한다. cbMultiByte 매개변수를 0으로 WideCharToMultiByte 함수를 호출하면 필요한 버퍼의 크기를 반환해 준다.
	과정은 유사하나 함수의 반환 값이 성공적인 반환을 위해 필요한 바이트 수를 반환한다는 점이 다르다!

	WideCharToMultiByte 함수는 MultiByteToWideChar 함수에 비해 추가적으로 2개의 매개변수(pDefaultChar와 pfUsedDefaultChar)를 더 필요로 한다는 점에 주의해야 한다.
	WideCharToMultiByte 함수에 의해서만 사용되는 이러한 매개변수들은 변경할 와이드 문자가 uCodePage에 의해 지정된 코드 페이지 내에 적절한 문자가 존재하지 않을 경우 사용된다.
	와이드 문자가 적절히 변경될 수 없는 경우 pDefaultChar 매개변수에 의해 지정된 문자로 대체된다. 
	대부분의 사용 예와 같이 이 매개변수를 NULL로 지정하면 시스템 기본 문자인 물음표로 대체되는데, 물음표가 와일드카드 문자로 사용되는 경우에 적용되면 매우 위험하다.
	
	pfUsedDefaultChar 매개변수에는 BOOL 값을 가리키는 포인터가 전달되며, 변경할 와이드-문자 문자열 중 한 자라도 멀티바이트-문자 문자열로 변경하는 것이 실패하는 경우 TRUE가 전달된다.
	반면, 모든 문자열에 대해 변경이 성공적이면 FALSE를 반환한다. 하지만 이 매개변수로는 NULL을 전달하는 것이 일반적이다.
		

		
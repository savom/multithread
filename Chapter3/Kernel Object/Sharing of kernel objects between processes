프로세스간 커널 오브젝트의 공유

	서로 다른 프로세스에서 각기 수행되는 스레드들 간에 동일 커널 오브젝트를 공유해야 하는 상황의 예시
		- 파일-매핑(file-mapping) 오브젝트는 단일 머신에서 수행되는 두 프로세스 사이에서 데이터의 블록을 공유할 수 있도록 해준다.
		- 메일슬롯(mailslot)과 명명 파이프(named pipe)를 이용하면 네트워크로 연결된 서로 다른 머신 사이에서 데이터를 주고 받을 수 있다.
		- 뮤텍스(mutex), 세마포어(semaphore), 이벤트(event)는 서로 다른 프로세스에서 수행되는 스레드 간에 동기화를 ㅅ수행할 수 있게 해 준다.
		  이를 이용하면 애플리케이션이 특정 작업을 완료했을 떄 다른 애플리케이션에게 완료 사실을 통보해 줄 수 있다.
	
	커널 오브젝트의 핸들은 프로세스별로 고유한 값이기 때문에 이러한 핸들 값을 공유하는 것은 간단하지 않다.
	핸들을 프로세스별로 고유한 값으로 설계한 가장 중요한 이유는 '안정성'이다.
	또 다른 이유는 프로세스별로 고유한 핸들이 좀 더 보안에 강하기 때문이다. 
	커널 오브젝트는 보안 요소에 의해 보호되고 있으며, 커널 오브젝트를 사용하기 위해서는 먼저 적절한 권한을 휙득해야하만 한다.

	1. 오브젝트 핸들의 상속을 이용하는 방법
		오브젝트 핸들의 상속은 오브젝트를 공유하고자 하는 프로세스들이 부모-자식관계를 가질 때에만 사용될 수 있다.
		즉, 하나 혹은 다수의 커널 오브젝트 핸들이 부모 프로세스에 의해 사용되고 있고, 
		부모 프로세스가 새로운 자식 프로세스를 생성하기로 결정하였을 때 자식 프로세스가 부모 프로세스가 사용하고 있는 커널 오브젝트에 접근할 수 있도록 해 주는 방법이다.

		부모 프로세스는 커널 오브젝트를 생성할 때 이를 가리키는 핸들이 상속될 수 있음을 시스템에게 알려주어야한다.(핸들이 상속되는 것이지 오브젝트 자체가 상속되는 것은 아님!)

		상속 가능한 핸들을 만들기 위해서는 페어런트 프로세스가 SECURITY_ATTRIBUTES 구조체를 초기화하고 이렇게 초기화된 값을 Create함수에 전달해야 한다.

		ex) Mutex오브젝트

			SECURITY_ATTRIBUTES sa;
			sa.nLength = sizeof(sa);
			sa.lpSecurityDescriptor = NULL;
			sa.bInheritHandle = TURE; // 상속 가능한 핸들을 만든다.

			HANDLE hMutex = CreateMutex(&sa, FALSE, NULL)

		위 코드는 기본 보안 디스크립터를 사용하고 상속 가능한 핸들을 반환하도록 SECURITY_ATTRIBUTES를 초기화한다.

		각 핸들 테이블 요소는 핸들이 상속 가능한지 여부를 가리키는 플래그 비트를 가지고 있다.
		커널 오브젝트를 생성할 때  SECURITY_ATTRIBUTES 매개변수로 NULL을 전달하면 반환되는 핸들은 상속 불가능 하며, 상속 가능여부를 나타내는 비트는 0이 된다.
		bInheritHandle 멤버를 TRUE로 지정하면 이 플래그 비트를 1로 설정한다.

		상속 가능한 오브젝트 핸들을 사용하기 위한 다음 단계는 부모 프로세스가 자식 프로세스를 생성하는 것이다.
		ex) CreateProcess 함수

		BOOL CreateProcessA(
			_In_opt_ LPCSTR lpApplicationName,
			_Inout_opt_ LPSTR lpCommandLine,
			_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
			_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
			_In_ BOOL bInheritHandles, << 요기
			_In_ DWORD dwCreationFlags,
			_In_opt_ LPVOID lpEnvironment,
			_In_opt_ LPCSTR lpCurrentDirectory,
			_In_ LPSTARTUPINFOA lpStartupInfo,
			_Out_ LPPROCESS_INFORMATION lpProcessInformation);

		보통 프로세스를 생성할 때 이 매개변수에 FALSE 값을 전달한다. 
		이 매개변수는 시스템에게 자식 프로세스가 부모 프로세스 핸들 테이블에 있는 상속 가능한 핸들을 상속하기를 원하지 않는다는 것을 시스템에게 알려주는 역활을 한다.

		bInheritHandles 매개변수로 True를 전달하면 자식 프로세스는 부모 프로세스의 '상속 가능한 핸들 값'들을 상속하게 된다. 
		이 매개변수에 True를 전달하여 CreateProcess 함수를 호출하면 운영체제는 자식 프로세스를 생성한다.
		하지만 자식 프로세스가 코드를 바로 수행하는 것을 허용하지 않는다.
		자식 프로세스를 생성하는 과정에서 비어 있는 프로세스 핸들 테이블이 만들어진다.
		하지만 CreateProcess의 bInheritHandles 매개변수에 True를 전달하면 운영체제는 한 가지 추가적인 작업을 수행한다.
		그것은 부모 프로세스의 핸들 테이블을 조사하여 '상속 가능한 핸들을 찾아내는 일'이다.
		시스템은 찾아낸 항목들을 자식 프로세스의 핸들 테이블에 복사한다.
		이때 자식 프로세스 핸들 테이블 내의 복사 위치는 부모 프로세스 핸들 테이블에서의 위치와 일치한다.
		이렇게 함으로써, 특정 커널 오브젝트를 구분하는 핸들 값이 부모 프로세스와 자식 프로세스에 걸쳐 동일한 값을 이용할 수 있게 되기 때문이다.

		두 개의 프로세스가 동일한 커널 오브젝트를 사용하게 되므로, 운영체제는 핸들 테이블의 항목을 복사하는 작업과 병행하여 '커널 오브젝트 내의 사용 카운트를 증가시킨다.'
		커널 오브젝트를 파괴하려면 부모 프로세스와 자식 프로세스 양쪽에서 모두 CloseHandle 함수를 호출하거나 프로세스를 종료하면 된다.

		사실 부모 프로세스는 CreateProcess함수가 반환되면 자식 프로세스가 오브젝트를 사용하기 전이라 하더라도 그 즉시 오브젝트 핸들을 삭제할 수 있다.

		커널 오브젝트의 내용은 운영체제에서 수행되는 모든 프로세스가 공유할 수 있는 커널 주소 공간 상에 저장된다.
		액세스 마스크는 부모 프로세스의 엑세스 마스크와 동일하며, 플래그 정보도 동일하다. 따라서 자식 프로세스가 bInheritHandles 매개변수를 True로 CreateProcess를 호출하여
		자신의 자식 프로세스(그랜드차일드)를 생성하면 생성된 프로세스 또한 동일한 핸들값, 동일한 엑세스 마스크, 동일한 플래그를 상속받을 것이며, 오브젝트에 대한 사용자 카운트는 증가될 것이다.

		오브젝트 핸들 상속은 자식 프로세스를 새로 생성할 때에만 적용이 가능함을 기억해야 한다.
		만약 부모 프로세스가 상속이 가능하도록 새로운 커널 오브젝트를 생성한다 하더라도, 이미 수행되고 있었던 자식 프로세스는 이 새로운 핸들을 상속받지 못한다.

		오브젝트 핸들 상속은 매우 이상한 특징을 하나 가지고 있는데, 오브젝트 핸들 상속을 사용하면서 자식 프로세스는 어떤 핸들이 상속될 것인지 알 수 없다.
		커널 오브젝트 핸들 상속은 자식 프로세스가 다른 프로세스에 의해 생성될 때 어떤 커널 오브젝트에 접근해야 할ㄹ지 알고 있을 때에 한해서 유용하다.
		보통의 경우 부모 애플리케이션과 자식 애플리케이션은 같은 회사에서 제작되므로 문제가 되지 않는다.
		하지만 자식 애플리케이션이 어떤 커널 오브젝트 핸들을 필요로 하는지 충분한 명세를 제공한다면 다른 회사에서 자식 애플리케이션을 작성하는 것도 불가능은 아니다.

		자식 프로세스가 사용할 커널 오브젝트의 핸들을 전달하는 가장 일반적인 방법은 자식 프로세스 수행 시 '명령행 인자를 이용하여' 커널 오브젝트의 핸들 값을 전달하는 것이다.
		자식 프로세스의 초기화 코드는 명령행 인자를 분석해여 핸들 값을 얻어낼 수 있다.
		이렇게 획득한 핸들 값은 부모 프로세스에서와 동일한 접근 권한을 가지게 된다.
		핸들 상속은 공유 커널 오브젝트에 대한 핸들 값이 부모 프로세스와 자식 프로세스 사이에서 동일하게 유지되는 유일한 방법이기도 하다.

		프로세스간 통신 방법을 이용하여 부모 프로세스가 자식 프로세스에게 상속한 커널 오브젝트의 핸들을 전달할 수도 있다.
			1. 부모 프로세스가 자식 프로세스가 완전히 초기화될 때까지 대기한 후에 자식 프로세스의 스레드가 생성한 윈도우로 메세지를 send하거나 post하는 것이다.
			2. 부모 프로세스가 환경변수 블록에 상속할 커널 오브젝트에 대한 핸들 값을 가지고 있는 새로운 환경변수를 추가하는 것이다.
				변수의 이름은 자식 프로세스와 약속된 이름이라면 무엇이든 사용될 수 있다. 부모 프로세스가 자식 프로세스를 생성하면 자식 프로세스는 부모 프로세스의 환경변수를 상속하게 되는데,
				이때 상속된 핸들 값을 얻기 위해 단순히 GetEnvironmentVariable 함수를 호출하면 된다.

		1-1 핸들 플래그를 변경하는 방법
			부모 프로세스가 상속 가능한 커널 오브젝트 핸들을 생성한 이후에 두 개의 자식 프로세스를 생성해야 하고,
			이 중 하나의 자식 프로세스에게만 커널 오브젝트 핸들을 상속하고 싶을 수 있다.
			다시 말해, 특정 자식 프로세스만이 커널 오브젝트 핸들을 상속하도록 제어하고 싶을 수 있는데,
			이런 경우 SetHandleInfomtion 함수를 이용하여 커널 오브젝트 핸들의 상속 플래그를 변경하면 된다.
				BOOL SetHandleInformation(
					_In_ HANDLE hObject,
					_In_ DWORD dwMask,
					_In_ DWORD dwFlags);
			첫 번째 매개변수인 hObject는 유효한 핸들 값을 전달하고, 두 번째 매개변수인 dwMask에는 어떤 플래그를 변경하고자 하는지를 전달한다.
		
			이 핸들과 관련해서 2개의 플래그가 정의되어 있다
				#define HANDLE_FLAG_INHERIT				0x00000001
				#define HANDLE_FLAG_PROTECT_FROM_CLOSE  0x00000002
			두 개의 플래그를 동시에 지정하기 위해서는 비트 OR연산을 사용하면 된다.
			세번째 매개변수인 dwFlags는 설정하고자 하는 플래그를 전달한다.

			ex) 커널 오브젝트 핸들의 상속 가능여부를 표현하는 플래그를 설정하기 위한 예시
				SetHandleInfomtion(hObj, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);

			ex) 상속 가능 여부를 표현하는 플래그를 끄는 예시
				SetHandleInfomtion(hObj, HANDLE_FLAG_INHERIT, 0);

			HANDLE_FLAG_PROTECT_FROM_CLOSE는 운영체제에게 이 플래그가 설정된 핸들은 삭제할 수 없음을 알려주는 플래그다.
				SetHandleInfomtion(hObj, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);
				CloseHandle(hObj); // 예외가 발생.

			디버거가 프로세스를 디버깅 중에 보호된 핸들을 종료하려 하면 CloseHandle함수가 예외를 발생시킨다.
			그렇지 않으면 CloseHandle은 단순히 False값을 반환한다.

			이 플래그는 자식 프로세스가 또 다른 자식 프로세스를 생성하는 구조를 가진 부모 프로세스를 만들어야 하는 경우에 유용하게 사용될 수 있다.
			부모 프로세스가 자식 프로세스를 거쳐 그랜드차일드 프로세스에게까지 오브젝트 핸들을 전달하고자 한다고 하자.
			이 경우 자식 프로세스가 그랜드 차일드 프호세스를 생성하기도 전에 상속받은 핸들을 닫아버리려고 시도할 수도 있다.
			이 경우 부모 프로세스는 그랜드차일드 프로세스와 핸들을 이용한 통신에 실패할 것이다.
			이 경우 HANDLE_FLAG_PROTECT_FROM_CLOSE를 지정한 보호된 핸들을 이용하면 그랜드차일드 프로세스가 유효한 핸들을 받을 가능성이 좀 더 증대된다.

	2. 명명된 오브젝트를 사용하는 방법
		
		대부문의 커널 오브젝트는 이름을 가질 수 있다.
		Create* 함수들은 공통적으로 마지막 매개변수로 pszName을 가진다.
		이 매개변수로 NULL을 전달하면 명명되지 않은 커널 오브젝트를 생성하게 된다.
		명명되지 않은 오브젝트를 생성할 경우라도 핸들 상속이나 DuplicateHandle을 이용하여 프로세스 간에 커널 오브젝트를 공유할 수 있다.
		pszName에 NULL을 전달하는 대신 '\0'으로 끝나는 문자열을 가리키는 주소를 전달하여 오브젝트의 이름을 지정할 수 있다.

		명명된 오브젝트가 이미 생성되어 있는 경우에 한해서만 활용할 수 있는 함수들도 있는데,
		Open*류의 함수가 이러한 부류의 함수다.

		마지막 매개변수인 pszName은 커널 오브젝트의 이름을 지정하는 데 사용된다.
		이 값으로 NULL을 사용해서는 안되며, 반드시 '\0'로 끝나는 문자열을 지정해야 한다.
		이러한 함수들은 커널 오브젝트를 위한 단일 네임스페이스로 내에에서 검색을 시도한다.
		지정된 이름의 오브젝트를 발견하지 못하면 함수는 NULL을 반환하고, GetLastError는 2(Error_file_not_found)를 반환한다.
		만일 커널 오브젝트가 존재하지만 타입이 틀릴 경우 NULL을 반환하는 것은 같지만 GetLastError가 6(Error_Invalid_Handle)을 반환한다.
		타입까지 일치하면 다음으로 (dwDesiredAccess 매개변수를 통해) 요청된 접근 권한이 허가되는지를 확인한다.
		그렇다면 함수를 호출한 프로세스의 핸들 테이블이 갱신되고, 커널 오브젝트의 사용 카운트가 증가된다.

		Create*류의 함수와 Open*류의 함수 사이의 주요 처이점은 커널 오브젝트가 존재하지 않는 경우 Create*류의 함수는 새로운 오브젝트를 생성하지만 Open*류의 함수는 실패한다.

		명명된 오브젝트는 동일한 애플리케이션이 여러 번 수행되지 못하도록 하기 위해서도 자주 사용된다.

		2-1 터미널 서비스 네임스페이스
			
			터미널 서비스의 경우 앞선 시나리오와 조금 차이가 있다.
			터미널 서비스를 수행하는 머신은 커널 오브젝트에 대해 다수의 네임스페이스를 가진다.
			모든 터미널 서비스 클라이언트 세션에서 접근 가능한 커널 오브젝트를 위한 전역 네임스페이스가 있는데,
			이는 주로 서비스타입의 애플리케이션에 의해 사용된다.
			각 클라이언트 세션은 자신만의 고유 네임스페이스를 가지게 된다.
			이러한 구성으로 두 개 혹은 다수의 세션에서 동일한 애플리케이션이 각기 수행될지라도 서로간에 영향을 미치지 않게 된다.
			하나의 세션은 설사 오브젝트의 이름이 같은 경우라 하더라도 다른 세션의 오브젝트에 접근할 수 없다.

			서비스에서 사용되는 명명된 커널 오브젝트는 항상 전역 네임스페이스에 생성된다.
			터미널 서비스에서 기동되는 애플리케이션은 각 세션별 네임스페이스 내에 명명된 커널 오브젝트를 생성한다.
			하지만 오브젝트의 이름 앞에 "Global\\" 를 붙여주어 전역 네임스페이스 내에 커널 오브젝트를 생성하도록 명시할 수도 있다.
				ex) HANDLE h = CreateEvent(NULL, FALAS, FALSE, TEXT("Global\\MyName"));

			또한 오브젝트의 이름 앞에 "Local\\"를 붙여주어 현재 세션의 네임스페이스 내에서 커널 오브젝트를 생성하도록 명시할 수도 있다.
				ex) HANDLE h = CreateEvent(NULL, FALAS, FALSE, TEXT("Local\\MyName"));

			마이크로소프트는 Global과 Local을 예약된 키워드로 간주하며, 특별히 네임스페이스의 위치를 지정할 때를 제외하고는 오브젝트 이름에 이를 사용하지 않도록 권고한다.

		2-2 프라이비트 네임스페이스(private namespace)
			
			커널 오브젝트를 생성핼 때 SECURITY_ATTRIBUTES 구조체의 포인터를 전달함으로써 오브젝트에 대한 접근을 보호할 수 있다.
			따라서 프로세스 간에 공유할 필요가 없는 오브젝트의 경우 명명되지 않은 커널 오브젝트를 사용하는 것이 좀 더 일반적이다.

			애플리케이션에서 생성한 명명된 커널 오브젝트가 다른 애플리케이션에서 사용하는 오브젝트의 이름과 절대로 충돌하지 않으며,
			이름을 훔치려는 시도로부터 안전하기를 원한다면 Global이나 local을 사용하는 것과 같이 사용자 고유의 프라이비트 네임스페이스를 만들어서 사용하면 된다.

			서버 프로세스는 네임스페이스 이름 자체를 보호하기 위해 바운더리 디스크립터를 생성하고 이를 이용하여 프라이비트 네임스페이스를 생성해야 한다.
			(singletone.cpp를 봐라)
			singletone.cpp에 있는 소스 코드에 포함된 CheckInstance 함수는 바운더리 디스크립터를 어떻게 생성하고,
			로컬 관리자 그룹을 나타내는 보안 식별자를 바운더리 디스크립터에 어떻게 추가하는지를 보여준다.
			
			바운더리 디스크립터도 이름을 가지지만 이보다 더 중요한 것은 바운더리 디스크립터에 추가된 사용자 그룹을 나타내는 SID 값이다.
			윈도우는 이 값을 통해 바운더리 디스크립터에 추가된 사용자 그룹에 속한 사용자의 수행 권한 하에서 수행되는 애플리케이션만이 동일한 바운더리 내의 동일 네임스페이스를 생성할 수 있도록 해 준다.
			동일 바운더리 내의 프라이비트 네임스페이스 이름을 접두어로 하는 커널 오브젝트에 접근할 수 있도록 해준다.

			만일 낮은 권한의 멜웨어 애플리케이션이 오브젝트의 이름과 SID를 훔칠 목적으로 동일한 바운더리 디스크립터를 생성하려는 경우 이러한 함수 호출은 실패하 것이며,
			GetLastError는 Error_access_denied를 반환한다.

			CheckInstances 함수를 각 단계별로 알아보자.
			바운더리 디스크립터를 생성하기 위해서는 문자열 식별자가 필요하며, 이 값은 프라이비트 네임스페이스를 정의할 때 사용된다. 이러한 문자열은 다음 함수의 첫 번쨰 매개변수를 통해 전달된다.

				HANDLE CreateBoundaryDescriptorA(
					_In_ LPCSTR Name,
					_In_ ULONG Flags);

			현재 버전의 윈도우는 두 번쨰 매개변수를 사용하지 않는다. 따라서 이 값으로는 단순히 0을 전달하는 것이 좋다.
			함수의 원형만 보아서는 반환 값이 커널 오브젝트의 핸들처럼 보인다.
			하지만 반환 값은 바운더리의 정의를 담고 있는 사용자-모드 구조체를 가리키는 포인터다.
			따라서 이를 삭제하려는 경우 CloseHandle함수에 사용해서는 안되고, DeleteBoundaryDescriptor 함수를 사용해야 한다.

			클라이언트 애플리케이션을 수행하리라 예상되는 사용자의 권한 그룹을 나타내는 SID 값을 다음 함수를 호출하여 바운더리 디스크립터에 추가한다.

				BOOL AddSIDToBoundaryDescriptor(
					_Inout_ HANDLE* BoundaryDescriptor,
					_In_ PSID RequiredSid);

			로컬 관리자 그룹의 SID 값을 생성하기 위해 SECURITY_BUILIN_DOMAIN_RID와 DOMAIN_ALLAS_RID_ADMINS 매개변수를 이용하여 AllocateAndInitializeSid 함수를 호출할 수도 있으나,
			CreateWellknownSid함수를 이용할 수도 있다.

			바운더리 디스크립터 핸들은 프라이비트 네임스페이스를 생성하기 위해 CreatePrivateNameSpace 함수를 호출할 때 두 번째 매개변수로 전달된다.
				
				HANDLE CreatePrivateNamespaceA(
					_In_opt_ LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
					_In_     LPVOID lpBoundaryDescriptor,
					_In_     LPCSTR lpAliasPrefix);

			CreatePrivateNameSpace 함수의 첫 번째 매개변수로 전달하는 SECURITY_ATTRIBUTES는 다른 애플리케이션이 OpenPrivateNameSpace를 호출하여 네임스페이스에 접근할 수 있는지,
			네임스페이스 내에 존재하는 오브젝트를 열거나 생성할 수 있는지의 등의 여부를 결정하기 위해 윈도우에 의해 사용된다.

			파일시스템의 디렉터리에도 이와 완전히 동일한 옵션들이 있다.
			바운더리 디스크립터에 추가된 SID는 누가 바운더리 내로 진입할 수 있는지,
			누가 네임스페이스를 생성할 수 있는지 여부 등의 내용을 결정하는 데 사용된다.

			CreateBoundartDescriptor 함수의 반환형이 HANDLE형임에도 불구하고 pvBoundaryDescriptor 매개변수는 pvoid형으로 정의되어 있다.
			세 번쨰 매개변수로 커널 오브젝트의 이름을 명명할 때 사용할 접두어 문자열을 전달한다.

			CreatePrivateNamespace나 OpenPrivateNamespace의 반환 값은 커널 오브젝트의 핸들이 아님을 주의하자.
			반환된 핸들 값은 ClosePrivateNamespace를 통해 삭제해야 한다.

				BOOLEAN ClosePrivateNamespace(
					_In_ HANDLE Handle,
					_In_ ULONG Flags);

			만일 네임스페이스를 생성하였고, 네임스페이스를 삭제한 이후에 그것이 가시적으로 드러나는 것을 원하지 않는다면,
			두 번째 매개변수로 0을 주는 대신 PRIVAATE_NAMESPACE_FLAG_DESTROY를 주면 된다.
			바운더리는 프로세스가 종료되거나 바운더리를 나타내는 가상 핸들을 인자로 하여 DeleteBoundaryDescriptor 함수를 호출할 때 삭제된다.

			커널 오브젝트가 사용 중인 프라이비트 네임스페이스를 삭제하면 안된다.
			프라이비트 네임스페이스를 삭제하면 동일 바운더리 내에 동일 네임스페이스를 재생성한 후 동일 이름의 커널 오브젝트를 생성할 수 있게 된다.(이러면 Dos공격 들어옴)

			프라이비트 네임스페이스는 커널 오브젝트를 담기 위한 디렉터리와 같다.
			디렉터리처럼 프라이비트 네임스페이스는 보안 디스크립터를 가지고 있고, 이 값은 CreatePrivateNamespace를 호출할 때 연계된다.
			하지만 파일시스템의 디렉터리와 다른 점도 있는데, 네임스페이스는 상위 디렉터리를 가지지 않고 이름도 가지지 않는다.

			프라이비트 네임스페이스에 부여한 이름은 프로세스 내에서만 보이는 별칭과도 같다.
			다른 프로세스들은 동일한 프러이비트 네임스페이스를 열어서 다른 별칭을 부여할 수도 있다.
			일반적으로 파일시스템에 디렉터리를 생성하려 할 때 상위 디렉터리의 권한을 먼저 확인하여 하위 디렉터리를 생성할 수 있는지의 여부를 확인하는 것처럼
			네임스페이스를 생성할 떄에도 바운더리에 대한 테스트가 먼저 수헹된다.
				이떄 현재 스레드의 토큰은 반드시 바운더리 디스크립터가 가지고 있는 SID값을 포함하고 있어야 한다.

	3. 오브젝트 핸들의 복사를 이용하는 방법
		
		프로세스 간에 커널 오브젝트를 공유하는 마지막 방법은 DuplicateHandle 함수를 사용하는 것이다.

			BOOL DuplicateHandle(
				_In_ HANDLE hSourceProcessHandle,
				_In_ HANDLE hSourceHandle,
				_In_ HANDLE hTargetProcessHandle,
				_Outptr_ LPHANDLE lpTargetHandle,
				_In_ DWORD dwDesiredAccess,
				_In_ BOOL bInheritHandle,
				_In_ DWORD dwOptions);

					
		DuplicateHandle 함수는 특정 프로세스 핸들 테이블 내의 항목을 다른 프로세스 핸들 테이블로 복사하는 함수다.
		DuplicateHandle은 여러 개의 매개변수를 취하지만 매우 직관적이다.
		DuplicateHandle 함수는 3개의 서로 다른 프로세스가 수행 중인 경우에도 사용될 수 있다.

		DuplicateHandle 함수를 사용하려면 첫 번째와 세 번째 매개변수인 hSourceProcessHandle과 hTargetProcessHandle에 프로세스 커널 오브젝트의 핸들을 넘겨줘야 한다.
		이러한 핸들은 DuplicateHandle 함수를 호출하는 프로세스와 연결되어 있는 프로세스들일 것이며,
		추가로 이 두 매개변수에는 반드시 프로세스 커널 오브젝트에 대한 핸들을 전달해야 한다.

		두 번쨰 매개변수인 hSourceHandle로는 어떤 타입의 커널 오브젝트라도 전달할 수 있으며,
		DuplicateHandle 함수를 호출한 프로세스와 아무런 연관성을 가지지 않는다.
		대신 hSourceProcessHandle 매개변수로 지정된 핸들 값이 가리키는 프로세스에서만 의미를 가지는 프로세스 고유의 값이다.

		네 번쨰 매개변수인 lpTargetHandle로는 HANDLE 변수의 주소 값을 전달하게 되며, 
		함수 호출 이후에 hTargetProcessHandle 값이 가리키는 프로세스에서만 사용될 수 있는 고유의 핸들 값을 전달받게 된다.(물론 이 값은 소스 핸들의 복사본이다)

		DuplicateHandle의 마지막 3개의 매개변수에는 타깃 프로세스 고유의 커널 오브젝트 핸들이 가진 속성 정보인 액세스 마스크와 상속 플래그의 값을 지정하게 된다.
		dwOptions 매개변수는 0, DUPLICATE_SAME_ACCESS와 DUPLICATE_CLOSE_SOURCE의 조합으로 지정될 수 있다.

		DUPLICATE_SAME_ACCESS를 지정하면 타깃 핸들이 소스 프로세스의 핸들과 동일한 액세스 마스크를 가지기를 원한다는 사실을 DuplicateHandle에게 알려주게 된다.
		이 플래그를 사용하면 dwDesiredAccess 매개변수는 무시된다.

		DUPLICATE_CLOSE_SOURCE를 지정하면, 소스 프로세스의 핸들을 삭제한다.
		이 플래그를 사용하면 하나의 프로세스에서 다른 프로세스로 쉽게 커널 오브젝트를 이동시킬 수 있으며,
		커널 오브젝트의 사용 카운트에는 영향을 주지않는다.
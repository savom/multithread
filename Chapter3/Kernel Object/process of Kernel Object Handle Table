프로세스의 커널 오브젝트 핸들 테이블
	 프로세스가 초기화되면 운영체제는 프로세스를 위해 커널 오브젝트 핸들 테이블을 할당한다.
	이러한 핸들 테이블은 사용자 오브젝트나 GDI 오브젝트에 의해서는 사용되지 않고 유일하게 커널 오브젝트에 의해서만 사용된다.
	프로세스 핸들 테이블의 구조는 단순한 데이터 구조체의 배열로 이루어져 있으며, 각 데이터 구조체는 커널 오브젝트에 대한 포인터, 액세스 마스크, 플래그로 구성된다.

커널 오브젝트 생성하기
	 프로세스가 최초로 초기화되면 프로세스의 핸들 테이블은 비어있다.프로세스 내의 스레드가 함수를 호출하면 커널은 커널 오브젝트를 위한 메모리 블록을 할당하고
	초기화한다. 커널은 프로세스의 핸들 테이블을 조사하여 비어 있는 공간을 찾아낸다.
	핸들 테이블은 완전히 비어 있기 떄문에 커널은 인덱스가 1인 위치를 찾아내고 초기화를 수행한다.
	포인터 멤버는 커널 오브젝트의 자료 구조를 가리키는 내부적인 메모리 주소로 할당되며, 액세스 마스크는 "풀 엑세스"로, 플래그는 "설정" 상태로 초기화된다.

	커널 오브젝트를 생성하는 함수(예시)

	HANDLE WINAPI CreateThread(
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_ SIZE_T dwStackSize,
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_opt_ __drv_aliasesMem LPVOID lpParameter,
    _In_ DWORD dwCreationFlags,
    _Out_opt_ LPDWORD lpThreadId
    );

	 커널 오브젝트를 생성하는 모든 함수는 프로세스별로 고유한 핸들 값을 반환하며, 이 값은 프로세스 내의 모든 스레드들에 의해 사용될 수 있다.
	핸들 값을 4로 나누면 커널 오브젝트에 대한 정보를 저장하고 있는 프로세스 핸들 테이블의 인덱스 값을 얻을 수 있다.
	애플리케이션을 디버깅하거나 커널 오브젝트 핸들의 실제 값을 조사해 보면 4, 8등과 같이 작은 값을 가지고 있음을 볼 수 있다.
	핸들 값 자체의 의미는 문서화되어 있지 않으며, 변경될 수 있음을 기억하길 바란다.

	 커널 오브젝트 핸들을 인자로 취하는 함수를 호출할 때에는 항상 Create* 류의 함수 중 하나를 호출하여 반환된 핸들 값을 전달해야한다
	이러한 함수들은 프로세스 핸들 테이블로부터 사용하고자 하는 커널 오브젝트의 실제 주소를 얻어낸 후 커널 오브젝트의 자료 구조를 변경한다.

	 만일 유효하지 않은 핸들 값을 전달하게 되면 이러한 함수들은 실패하고 GetLastError 호출 결과로 6(ERROR_INVALID_HANDLE)을 반환한다.
	핸들 값은 실제로 프로세스 핸들 테이블의 인덱스 값으로 활용될 수 있기 때문에 프로세스별로 고유한 값이며, 다른 프로세스에 의해 사용될 수 없는 값이다.
	만일 다른 프로세스와 공유를 시도하면 다른 프로세스의 프로세스 핸들 테이블로부터 동일한 인덱스 값을 가진 완전히 다른 커널 오브젝트를 참조하게 될 것이며, 이 오브젝트가 무엇인지에 대해서
	알 방법이 없다.
	
	커널 오브젝트를 생성하는 함수가 실패하면 반환되는 핸들 값은 보통 null이 된다.
	그 이유로는 유효한 커널 오브젝트 핸들 값은 4부터 시작된다. 시스템의 가용메모리가 매우 작거나 보안 문제로 인해 함수가 실패하는 경우 몇몇 함수는 불행히도
	-1(INVALID_HANDLE_VALUE, WinBase.h에 정의된)을 반환하는 경우가 있다. CreateFile 함수의 경우 주어진 파일을 여는 데 실패하면 Null 대신 INVALID_HANDLE_VALUE 값을 반환한다.
	따라서 커널 오브젝트를 생성하는 함수의 반환 값을 확인할 때에는 상당한 주의가 필요하다

	(예시 1)
	HANDLE WINAPI CreateMutexA(
    if (hMutex == INVALID_HANDLE_VALUE) {
		// CreateMutex의 호출이 실패할 경우 Null을 반환하기 때문에
		// if 이하의 코드는 실행되지 않는다.
	}
);

	(예시 2)
	HANDLE WINAPI CreateFileA(
	if (hFile == NULL)
		// CreateFile의 호출이 실패할 경우 INVALID_HANDLE_VALUE를 반환하기 때문에
		// 아래의 코드는 실행되지 않는다.
    _In_ LPCSTR lpFileName,
    _In_ DWORD dwDesiredAccess,
    _In_ DWORD dwShareMode,
    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    _In_ DWORD dwCreationDisposition,
    _In_ DWORD dwFlagsAndAttributes,
    _In_opt_ HANDLE hTemplateFile
    );

커널 오브젝트 삭제하기

	커널 오브젝트를 어떻게 생성했는지와 상관없이 CloseHandle 함수를 호출하여 더 이상 커널 오브젝트를 사용하지 않을 것임을 시스템에게 알려줄 수 있다.
		BOOL CloseHandle(HANDLE hobject);
	내부적으로 이 함수는 프로세스의 핸들 테이블을 검사해여 전달받은 핸들 값을 통해 실제 커널 오브젝트에 접근 가능한지를 확인한다.
	핸들이 유효한 값이고 시스템이 커널 오브젝트의 자료 구조를 획득하게 되면, 구조체 내의 사용 카운트멤버를 감소시킨다.
	만일 이 값이 0이 되면 커널 오브젝트를 파괴하고 메모리로부터 제거한다.
	
	 유효하지 않은 핸들을 CloseHandle 함수에 전달하면 두 가지 경우의 수가 생긴다.
	1. 프로세스는 정상적으로 수행되고 CloseHandle 함수는 False를 반환한다. GetLastError를 호출하면 INVALID_HANDLE_VALUE를 반환한다(-1)
		- 또 다른 경우로 프로세스가 디버깅 중인 경우로, 에러를 디버깅할 수 있도록 0XC0000008(유효하지 않은 핸들이 지정되었습니다.)예외가 발생한다.

	2. CloseHandle 하수는 반환되기 직전에 프로세스의 핸들 테이블에서 해당 항목을 삭제한다.
		- 이렇게 되면 핸들은 더 이상 유효하지 않은 값이 되고 이 핸들로는 어떠한 작업도 수행할 수 없다.
		  CloseHandle을 호출하면 더 이상 해당 커널 오브젝트에 접근하는 것이 불가능해지지만,
		  커널 오브젝트 자체는 삭제되었을 수도 있고 그렇지 않를 수도 있다. 오브젝트의 사용 카운트가 0이 되지 않는 이상 커널 오브젝트는 파괴되지 않는다.
		  하나 혹은 다수의 다른 프로세스가 해당 커널 오브젝트를 사용하고 있는 경우라면 커널 오브젝트는 삭제되지 않는다.
		  다른 모든 프로세스가 이 오브젝트를 더 이상 사용하지 않으면(CloseHandle을 사용하여) 오브젝트는 그때 비로소 파괴된다.

	 CloseHandle을 호출하는 것을 잊어버리면 오브젝트 누수가 발생하게 될까?
	프로세스가 계속해서 수행 중이라면 오브젝트 누수 상황이 될 수 있다. 하지만 프로세스가 종료되면 운영체제는 프로세스가 사용하던 모든 리소스들을 반환한다.
	커널 오브젝트의 경우 시스템은 다음과 같은 절차를 수행한다.
		프로세스가 종료되면 운영체제는 프로세스의 핸들 테이블을 검사하여 테이블 상에 유효한 항목이 있는 경우 오브젝트 핸들을 삭제한다.
		이 과정에서 커널 오브젝트의 사용 카운트가 0이 되면 커널 오브젝트도 파괴될 것이다.

	따라서 애플리케이션 수행 중에는 커널 오브젝트에 대한 누수가 발생할 수 있지만, 프로세스가 종료될 때에는 시스템이 적절하게 모든 오브젝트 핸들을 정리해 주는 것을
	보장하기 때문에 커널 오브젝트 누수 문제는 발생하지 않는다.

	"이러한 메커니즘은 GDI오브젝트나 메모리 블록들에 대해서도 동일하게 적용된다."

>>> Sharing of kernel objects between processes로
	